import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';

export interface Vulnerability {
  id: string;
  vulnerabilityName: string;
  cvssScore: number;
  severity: string;
  discoveredDate: string;
  cve_ids: string[];
  remediation: string | null;
  host_ip: string;
  description: string;
  status: string;
  exploitAvailable: boolean;
  patchAvailable: boolean;
  affectedAsset: string;
  epss: number;
}

@Injectable({
  providedIn: 'root'
})
export class VulnerabilityService {
  private apiUrl = 'http://127.0.0.1:8000/vulnerabilities/vuljson/';

  constructor(private http: HttpClient) {}

  /**
   * Fetch vulnerabilities from the API
   */
  getVulnerabilities(): Observable<Vulnerability[]> {
    console.log('Fetching vulnerabilities from API:', this.apiUrl);
    
    return this.http.get<{vulnerabilities: any[]}>(this.apiUrl).pipe(
      map(response => {
        console.log('API Response:', response);
        if (response && response.vulnerabilities && Array.isArray(response.vulnerabilities)) {
          return this.transformVulnerabilityData(response.vulnerabilities);
        }
        throw new Error('Invalid API response format');
      }),
      tap(vulnerabilities => {
        console.log('Transformed vulnerabilities:', vulnerabilities.length);
      }),
      catchError(error => {
        console.error('Error fetching vulnerabilities:', error);
        // Return empty array in case of error
        return of([]);
      })
    );
  }

  /**
   * Transform raw API data to Vulnerability objects
   */
  private transformVulnerabilityData(data: any[]): Vulnerability[] {
    if (!data || !Array.isArray(data)) {
      return [];
    }

    return data.map(item => {
      // Extract CVE IDs from the data
      let cveIds: string[] = [];
      if (item.cve_ids) {
        cveIds = Array.isArray(item.cve_ids) ? item.cve_ids : [item.cve_ids];
      } else if (item.cve_id) {
        cveIds = [item.cve_id];
      } else if (item.cve) {
        cveIds = [item.cve];
      }

      // Get CVSS score
      const cvssScore = item.cvssScore || item.cvss_score || item.cvss || 0;

      // Get severity
      let severity = item.severity || '';
      if (!severity) {
        severity = this.getSeverityFromCVSS(cvssScore);
      }

      // Generate a random ID if none exists
      const id = item.id || `vuln-${Math.random().toString(36).substring(2, 9)}`;

      return {
        id,
        vulnerabilityName: item.vulnerabilityName || item.title || item.name || 'Unknown Vulnerability',
        cvssScore: cvssScore,
        severity: severity,
        discoveredDate: item.discoveredDate || item.published_date || item.date || new Date().toISOString(),
        cve_ids: cveIds,
        remediation: item.remediation || null,
        host_ip: item.host_ip || item.host_name || item.host || item.affected_asset || '192.168.1.1',
        description: item.description || item.summary || '',
        status: item.status || 'open',
        exploitAvailable: item.exploitAvailable || item.exploit_available || false,
        patchAvailable: item.patchAvailable || item.patch_available || false,
        affectedAsset: item.affectedAsset || '',
        epss: item.epss || 0
      };
    });
  }

  /**
   * Get severity level from CVSS score
   */
  private getSeverityFromCVSS(cvss: number): string {
    if (cvss >= 9.0) return 'Critical';
    if (cvss >= 7.0) return 'High';
    if (cvss >= 4.0) return 'Medium';
    return 'Low';
  }
}
