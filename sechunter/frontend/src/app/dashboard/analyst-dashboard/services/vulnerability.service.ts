import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { BehaviorSubject, Observable, of, map, catchError, tap } from 'rxjs';
import { Vulnerability, VulnerabilityFilter, VulnerabilitySummary, VulnerabilityTrend, getSeverityFromCVSS } from '../models/vulnerability.model';

@Injectable({
  providedIn: 'root'
})
export class VulnerabilityService {
  private apiUrl = 'http://127.0.0.1:8000/vulnerabilities/vuljson/';

  private vulnerabilitiesSubject = new BehaviorSubject<Vulnerability[]>([]);
  private loadingSubject = new BehaviorSubject<boolean>(false);
  private errorSubject = new BehaviorSubject<string | null>(null);

  vulnerabilities$ = this.vulnerabilitiesSubject.asObservable();
  loading$ = this.loadingSubject.asObservable();
  error$ = this.errorSubject.asObservable();

  constructor(
    private http: HttpClient
  ) {}

  /**
   * Load vulnerabilities from the API
   */
  loadVulnerabilities(): Observable<Vulnerability[]> {
    this.loadingSubject.next(true);
    this.errorSubject.next(null);

    return this.http.get<{vulnerabilities: any[]}>(this.apiUrl).pipe(
      map(response => {
        console.log('API Response:', response);
        if (response && response.vulnerabilities && Array.isArray(response.vulnerabilities)) {
          return this.transformVulnerabilityData(response.vulnerabilities);
        }
        throw new Error('Invalid API response format');
      }),
      tap(vulnerabilities => {
        this.vulnerabilitiesSubject.next(vulnerabilities);
        this.loadingSubject.next(false);
      }),
      catchError(error => {
        console.error('Error loading vulnerabilities:', error);
        this.errorSubject.next('Failed to load vulnerability data');
        this.loadingSubject.next(false);
        return of([]);
      })
    );
  }

  /**
   * Transform raw API data to Vulnerability objects
   */
  private transformVulnerabilityData(data: any[]): Vulnerability[] {
    if (!data || !Array.isArray(data)) {
      return [];
    }

    return data.map(item => {
      // Extract CVE IDs from the data
      let cveIds: string[] = [];
      if (item.cve_ids) {
        cveIds = Array.isArray(item.cve_ids) ? item.cve_ids : [item.cve_ids];
      } else {
        cveIds = this.extractCveIds(item);
      }

      // Get CVSS score
      const cvssScore = item.cvssScore || item.cvss_score || item.cvssScore || 0;

      // Get severity
      let severity = item.severity || '';
      if (!severity) {
        severity = getSeverityFromCVSS(cvssScore).toString();
      }

      // Generate a random ID if none exists
      const id = item.id || item.plugin_id || `vuln-${Math.random().toString(36).substring(2, 9)}`;

      return {
        id,
        vulnerabilityName: item.vulnerabilityName || item.title || item.name || 'Unknown Vulnerability',
        cvssScore: cvssScore,
        severity: severity,
        discoveredDate: item.discoveredDate || item.published_date || item.date || new Date().toISOString(),
        cve_ids: cveIds,
        remediation: item.remediation || null,
        host_ip: item.host_ip || item.host_name || item.host || item.affected_asset || '192.168.1.1',
        description: item.description || item.summary || '',
        status: item.status || 'open',
        exploitAvailable: item.exploitAvailable || item.exploit_available || false,
        patchAvailable: item.patchAvailable || item.patch_available || false,
        affectedAsset: item.affectedAsset || '',
        epss: item.epss || 0
      };
    });
  }

  /**
   * Extract CVE IDs from vulnerability data
   */
  private extractCveIds(item: any): string[] {
    if (item.cve_ids && Array.isArray(item.cve_ids)) {
      return item.cve_ids;
    }

    if (item.cve_id) {
      return [item.cve_id];
    }

    if (item.cve) {
      return [item.cve];
    }

    // Try to extract CVE ID from title or description
    const cveRegex = /CVE-\d{4}-\d{4,7}/gi;
    let cveIds: string[] = [];

    if (item.title) {
      const matches = item.title.match(cveRegex);
      if (matches) {
        cveIds = [...cveIds, ...matches];
      }
    }

    if (item.description) {
      const matches = item.description.match(cveRegex);
      if (matches) {
        cveIds = [...cveIds, ...matches];
      }
    }

    return cveIds.length > 0 ? cveIds : ['CVE-XXXX-XXXXX'];
  }

  /**
   * Extract CVSS score from vulnerability data
   */
  private extractCvssScore(item: any): number {
    if (typeof item.cvss_score === 'number') {
      return item.cvss_score;
    }

    if (typeof item.cvss === 'number') {
      return item.cvss;
    }

    if (typeof item.score === 'number') {
      return item.score;
    }

    // Generate a random score between 4.0 and 9.9
    return Math.round((4 + Math.random() * 5.9) * 10) / 10;
  }

  /**
   * Filter vulnerabilities based on criteria
   */
  filterVulnerabilities(filter: VulnerabilityFilter): Observable<Vulnerability[]> {
    return this.vulnerabilities$.pipe(
      map(vulnerabilities => {
        let filtered = [...vulnerabilities];

        // Apply severity filter
        if (filter.severity && filter.severity.length > 0) {
          filtered = filtered.filter(vuln => filter.severity!.includes(vuln.severity));
        }

        // Apply CVSS range filter
        if (filter.cvssMin !== undefined) {
          filtered = filtered.filter(vuln => vuln.cvssScore >= filter.cvssMin!);
        }

        if (filter.cvssMax !== undefined) {
          filtered = filtered.filter(vuln => vuln.cvssScore <= filter.cvssMax!);
        }

        // Apply host filter
        if (filter.host && filter.host.length > 0) {
          filtered = filtered.filter(vuln => filter.host!.includes(vuln.host_ip));
        }

        // Apply CVE filter
        if (filter.cve) {
          filtered = filtered.filter(vuln =>
            vuln.cve_ids.some(cve => cve.includes(filter.cve!))
          );
        }

        // Apply date range filter
        if (filter.dateFrom) {
          const fromDate = new Date(filter.dateFrom);
          filtered = filtered.filter(vuln => new Date(vuln.discoveredDate) >= fromDate);
        }

        if (filter.dateTo) {
          const toDate = new Date(filter.dateTo);
          filtered = filtered.filter(vuln => new Date(vuln.discoveredDate) <= toDate);
        }

        // Apply remediation filter
        if (filter.remediation !== undefined) {
          filtered = filtered.filter(vuln =>
            filter.remediation ? vuln.remediation !== null : vuln.remediation === null
          );
        }

        // Apply search term filter
        if (filter.searchTerm) {
          const term = filter.searchTerm.toLowerCase();
          filtered = filtered.filter(vuln =>
            vuln.vulnerabilityName.toLowerCase().includes(term) ||
            vuln.description?.toLowerCase().includes(term) ||
            vuln.cve_ids.some(cve => cve.toLowerCase().includes(term)) ||
            vuln.host_ip.toLowerCase().includes(term)
          );
        }

        return filtered;
      })
    );
  }

  /**
   * Get vulnerability summary statistics
   */
  getVulnerabilitySummary(): Observable<VulnerabilitySummary> {
    return this.vulnerabilities$.pipe(
      map(vulnerabilities => {
        const summary: VulnerabilitySummary = {
          total: vulnerabilities.length,
          critical: 0,
          high: 0,
          medium: 0,
          low: 0,
          remediationAvailable: 0,
          remediationUnavailable: 0,
          byHost: {}
        };

        vulnerabilities.forEach(vuln => {
          // Count by severity
          switch (vuln.severity.toLowerCase()) {
            case 'critical':
              summary.critical++;
              break;
            case 'high':
              summary.high++;
              break;
            case 'medium':
              summary.medium++;
              break;
            case 'low':
              summary.low++;
              break;
          }

          // Count by remediation availability
          if (vuln.remediation) {
            summary.remediationAvailable++;
          } else {
            summary.remediationUnavailable++;
          }

          // Count by host
          if (!summary.byHost[vuln.host_ip]) {
            summary.byHost[vuln.host_ip] = 0;
          }
          summary.byHost[vuln.host_ip]++;
        });

        return summary;
      })
    );
  }

  /**
   * Get vulnerability trends over time
   */
  getVulnerabilityTrends(timeRange: 'week' | 'month' | 'quarter' | 'year'): Observable<VulnerabilityTrend[]> {
    return this.vulnerabilities$.pipe(
      map(vulnerabilities => {
        const now = new Date();
        let startDate: Date;

        // Determine start date based on time range
        switch (timeRange) {
          case 'week':
            startDate = new Date(now);
            startDate.setDate(now.getDate() - 7);
            break;
          case 'month':
            startDate = new Date(now);
            startDate.setMonth(now.getMonth() - 1);
            break;
          case 'quarter':
            startDate = new Date(now);
            startDate.setMonth(now.getMonth() - 3);
            break;
          case 'year':
            startDate = new Date(now);
            startDate.setFullYear(now.getFullYear() - 1);
            break;
        }

        // Filter vulnerabilities by date
        const filteredVulns = vulnerabilities.filter(vuln => {
          const vulnDate = new Date(vuln.discoveredDate);
          return vulnDate >= startDate && vulnDate <= now;
        });

        // Group by date
        const groupedByDate: { [key: string]: Vulnerability[] } = {};

        filteredVulns.forEach(vuln => {
          const date = new Date(vuln.discoveredDate);
          let dateKey: string;

          // Format date key based on time range
          switch (timeRange) {
            case 'week':
              dateKey = date.toISOString().split('T')[0]; // YYYY-MM-DD
              break;
            case 'month':
              dateKey = date.toISOString().split('T')[0]; // YYYY-MM-DD
              break;
            case 'quarter':
            case 'year':
              dateKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`; // YYYY-MM
              break;
          }

          if (!groupedByDate[dateKey]) {
            groupedByDate[dateKey] = [];
          }

          groupedByDate[dateKey].push(vuln);
        });

        // Create trend data
        const trends: VulnerabilityTrend[] = Object.keys(groupedByDate)
          .sort()
          .map(date => {
            const vulns = groupedByDate[date];
            const totalCvss = vulns.reduce((sum, vuln) => sum + vuln.cvssScore, 0);
            const avgCvss = totalCvss / vulns.length;

            return {
              date,
              count: vulns.length,
              avgCvss
            };
          });

        return trends;
      })
    );
  }
}



